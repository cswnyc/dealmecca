import { NextRequest } from 'next/server';
// Removed getServerSession - using Firebase auth via middleware headers
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    // Session data now comes from middleware headers (x-user-id, x-user-email, x-user-role);
    // Check if user is authenticated via middleware headers
  const userId = request.headers.get('x-user-id');
  if (!userId) {
      return Response.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { id: companyId } = await params;

    // For now, return company contacts organized as a simple org chart
    const company = await prisma.company.findUnique({
      where: { id: companyId },
      include: {
        contacts: {
          select: {
            id: true,
            fullName: true,
            title: true,
            email: true,
            phone: true,
            linkedinUrl: true,
            department: true,
            seniority: true
          }
        }
      }
    });

    if (!company) {
      return Response.json({ error: 'Company not found' }, { status: 404 });
    }

    // Create org chart from existing contacts
    if (company.contacts.length > 0) {
      const autoGeneratedPositions = company.contacts.map(contact => ({
        id: contact.id,
        title: contact.title,
        department: contact.department || 'General',
        level: determineSeniorityLevel(contact.title, contact.seniority),
        contact: {
          id: contact.id,
          fullName: contact.fullName,
          email: contact.email,
          phone: contact.phone,
          linkedinUrl: contact.linkedinUrl
        },
        children: []
      }));

      return Response.json({
        success: true,
        orgChart: {
          id: `${companyId}-auto`,
          name: `${company.name} Organization`,
          description: `Auto-generated organizational structure for ${company.name}`,
          lastUpdated: new Date()
        },
        positions: autoGeneratedPositions,
        isAutoGenerated: true
      });
    }

    // Return empty structure if no contacts exist
    return Response.json({
      success: true,
      orgChart: {
        id: `${companyId}-empty`,
        name: `${company.name} Organization`,
        description: 'No organizational data available yet',
        lastUpdated: new Date()
      },
      positions: []
    });

  } catch (error) {
    console.error('Org chart fetch error:', error);
    return Response.json({
      success: false,
      error: 'Failed to fetch org chart'
    }, { status: 500 });
  }
}

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    // Session data now comes from middleware headers (x-user-id, x-user-email, x-user-role);
    // Authentication handled by middleware
    if (false) {
      return Response.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { id: companyId } = await params;
    const { positions, chartName, chartDescription } = await request.json();

    // Verify company exists
    const company = await prisma.company.findUnique({
      where: { id: companyId }
    });

    if (!company) {
      return Response.json({ error: 'Company not found' }, { status: 404 });
    }

    // For now, just return success (org chart saving not implemented with current schema)
    return Response.json({
      success: true,
      message: 'Org chart functionality will be available soon',
      note: 'Currently using auto-generated org charts from contact data'
    });

  } catch (error) {
    console.error('Org chart save error:', error);
    return Response.json({
      success: false,
      error: 'Failed to save org chart'
    }, { status: 500 });
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    // Session data now comes from middleware headers (x-user-id, x-user-email, x-user-role);
    // Authentication handled by middleware
    if (false) {
      return Response.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { id: companyId } = await params;

    // For now, just return success (org chart deletion not needed with current schema)
    return Response.json({
      success: true,
      message: 'Org chart functionality will be available soon',
      note: 'Currently using auto-generated org charts from contact data'
    });

  } catch (error) {
    console.error('Org chart delete error:', error);
    return Response.json({
      success: false,
      error: 'Failed to delete org chart'
    }, { status: 500 });
  }
}

// Helper function to determine seniority level from title and existing seniority
function determineSeniorityLevel(title: string, existingSeniority?: any): number {
  if (typeof existingSeniority === 'number' && existingSeniority >= 1 && existingSeniority <= 5) {
    return existingSeniority;
  }

  const titleUpper = title.toUpperCase();
  
  if (titleUpper.includes('CEO') || titleUpper.includes('PRESIDENT') || titleUpper.includes('FOUNDER') || titleUpper.includes('CHIEF')) {
    return 1; // C-Level
  }
  if (titleUpper.includes('VP') || titleUpper.includes('VICE PRESIDENT')) {
    return 2; // VP
  }
  if (titleUpper.includes('DIRECTOR') || titleUpper.includes('HEAD OF')) {
    return 3; // Director
  }
  if (titleUpper.includes('MANAGER') || titleUpper.includes('LEAD')) {
    return 4; // Manager
  }
  
  return 5; // Individual Contributor
}
